// $ANTLR 2.7.7 (2006-11-01): "csv.g" -> "CSVLexer.java"$

package org.ceskaexpedice.processplatform.worker.api.service.os.windows.csv;

import antlr.*;
import antlr.collections.impl.BitSet;

import java.io.InputStream;
import java.io.Reader;
import java.util.Hashtable;

public class CSVLexer extends antlr.CharScanner implements CSVParserTokenTypes, TokenStream {
    public CSVLexer(InputStream in) {
        this(new ByteBuffer(in));
    }

    public CSVLexer(Reader in) {
        this(new CharBuffer(in));
    }

    public CSVLexer(InputBuffer ib) {
        this(new LexerSharedInputState(ib));
    }

    public CSVLexer(LexerSharedInputState state) {
        super(state);
        caseSensitiveLiterals = true;
        setCaseSensitive(true);
        literals = new Hashtable();
    }

    public Token nextToken() throws TokenStreamException {
        Token theRetToken = null;
        tryAgain:
        for (; ; ) {
            Token _token = null;
            int _ttype = Token.INVALID_TYPE;
            resetText();
            try {   // for char stream error handling
                try {   // for lexical error handling
                    switch (LA(1)) {
                        case '"': {
                            mRECORD(true);
                            theRetToken = _returnToken;
                            break;
                        }
                        case ',': {
                            mCOMMA(true);
                            theRetToken = _returnToken;
                            break;
                        }
                        case '\n':
                        case '\r': {
                            mNEWLINE(true);
                            theRetToken = _returnToken;
                            break;
                        }
                        case '\t':
                        case ' ': {
                            mWS(true);
                            theRetToken = _returnToken;
                            break;
                        }
                        default: {
                            if (LA(1) == EOF_CHAR) {
                                uponEOF();
                                _returnToken = makeToken(Token.EOF_TYPE);
                            } else {
                                throw new NoViableAltForCharException((char) LA(1), getFilename(), getLine(), getColumn());
                            }
                        }
                    }
                    if (_returnToken == null) continue tryAgain; // found SKIP token
                    _ttype = _returnToken.getType();
                    _ttype = testLiteralsTable(_ttype);
                    _returnToken.setType(_ttype);
                    return _returnToken;
                } catch (RecognitionException e) {
                    throw new TokenStreamRecognitionException(e);
                }
            } catch (CharStreamException cse) {
                if (cse instanceof CharStreamIOException) {
                    throw new TokenStreamIOException(((CharStreamIOException) cse).io);
                } else {
                    throw new TokenStreamException(cse.getMessage());
                }
            }
        }
    }

    public final void mRECORD(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
        int _ttype;
        Token _token = null;
        int _begin = text.length();
        _ttype = RECORD;
        int _saveIndex;

        match('"');
        {
            _loop19:
            do {
                if ((_tokenSet_0.member(LA(1)))) {
                    {
                        match(_tokenSet_0);
                    }
                } else {
                    break _loop19;
                }

            } while (true);
        }
        match('"');
        if (_createToken && _token == null && _ttype != Token.SKIP) {
            _token = makeToken(_ttype);
            _token.setText(new String(text.getBuffer(), _begin, text.length() - _begin));
        }
        _returnToken = _token;
    }

    public final void mCOMMA(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
        int _ttype;
        Token _token = null;
        int _begin = text.length();
        _ttype = COMMA;
        int _saveIndex;

        match(',');
        if (_createToken && _token == null && _ttype != Token.SKIP) {
            _token = makeToken(_ttype);
            _token.setText(new String(text.getBuffer(), _begin, text.length() - _begin));
        }
        _returnToken = _token;
    }

    public final void mNEWLINE(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
        int _ttype;
        Token _token = null;
        int _begin = text.length();
        _ttype = NEWLINE;
        int _saveIndex;

        boolean synPredMatched23 = false;
        if (((LA(1) == '\r'))) {
            int _m23 = mark();
            synPredMatched23 = true;
            inputState.guessing++;
            try {
                {
                    match('\r');
                    match('\n');
                }
            } catch (RecognitionException pe) {
                synPredMatched23 = false;
            }
            rewind(_m23);
            inputState.guessing--;
        }
        if (synPredMatched23) {
            match('\r');
            match('\n');
        } else if ((LA(1) == '\r')) {
            match('\r');
        } else if ((LA(1) == '\n')) {
            match('\n');
            if (inputState.guessing == 0) {
                newline();
            }
        } else {
            throw new NoViableAltForCharException((char) LA(1), getFilename(), getLine(), getColumn());
        }

        if (_createToken && _token == null && _ttype != Token.SKIP) {
            _token = makeToken(_ttype);
            _token.setText(new String(text.getBuffer(), _begin, text.length() - _begin));
        }
        _returnToken = _token;
    }

    public final void mWS(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
        int _ttype;
        Token _token = null;
        int _begin = text.length();
        _ttype = WS;
        int _saveIndex;

        {
            switch (LA(1)) {
                case ' ': {
                    match(' ');
                    break;
                }
                case '\t': {
                    match('\t');
                    break;
                }
                default: {
                    throw new NoViableAltForCharException((char) LA(1), getFilename(), getLine(), getColumn());
                }
            }
        }
        if (inputState.guessing == 0) {
            _ttype = Token.SKIP;
        }
        if (_createToken && _token == null && _ttype != Token.SKIP) {
            _token = makeToken(_ttype);
            _token.setText(new String(text.getBuffer(), _begin, text.length() - _begin));
        }
        _returnToken = _token;
    }


    private static final long[] mk_tokenSet_0() {
        long[] data = new long[1024];
        data[0] = -17179878408L;
        for (int i = 1; i <= 510; i++) {
            data[i] = -1L;
        }
        data[511] = 9223372036854775807L;
        return data;
    }

    public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());

}
